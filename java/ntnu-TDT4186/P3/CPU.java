
/**
 * The CPU of the simulated system.
 */
public class CPU {

    /** The maximum amount of time a process can use the CPU 'in one go' */
    private long maxTime;
    /** The active process performing IO */
    private Process process;
    /** Processes waiting to perform IO */
    private Queue queue;
    /** Reference to GUI */
    private Gui gui;
    /** Reference to statistics collector */
    private Statistics statistics;

    /**
     * Creates a new CPU with the given parameters.
     * @param maxTime       Aka Round-Robin time slot.
     * @param queue         Belonging to CPU.
     * @param gui           Interface.
     * @param statistics    Collector.
     */
    public CPU(long maxTime, Queue queue, Gui gui, Statistics statistics) {
        this.maxTime = maxTime;
        this.queue = queue;
        this.gui = gui;
        this.statistics = statistics;
    }

    /**
     * @return active process currently using CPU.
     */
    public Process getProcess() {
        return process;
    }

    /**
     * Called whenever time has passed.
     * @param time  Passed since the last call to this method.
     */
    public void timePassed(long time) {

        if (process != null) {
            process.cpuTimePassed(time);
            statistics.totalBusyCpuTime += time;
        }

        statistics.cpuQueueLengthTime += queue.getQueueLength()*time;

        if(queue.getQueueLength() > statistics.cpuQueueLargestLength) {
            statistics.cpuQueueLargestLength = queue.getQueueLength();
        }
    }

    /**
     * Put process in CPU queue. The process is activated if CPU is idle.
     * @param process   To be queued.
     * @param clock     Global time.
     * @return          Event causing active process to leave CPU, null if no process was activated.
     */
    public Event queueProcess(Process process, long clock) {
        queue.insert(process);
        // Active queued process if CPU is idle
        if(this.process == null) {
            return switchProcess(clock);
        }
        return null;
    }

    /**
     * Activates (switches in) the first process in the CPU queue, if the queue is non-empty.
     * The process that was using the CPU, if any, is switched out and added to the back of
     * the CPU queue, in accordance with the Round Robin algorithm.
     * @param clock The global time.
     * @return      The event causing the process that was activated to leave the CPU,
     *              or null if no process was activated.
     */
    public Event switchProcess(long clock) {

        if (!queue.isEmpty()) {
            // If the queue is empty the active process is allowed to continue
            if(process != null) {
                // Put the active process at the end of the queue
                process.leftCpu(clock);
                queue.insert(process);
                // Switch in a new process from the cpu queue
                process = (Process)queue.removeNext();
                process.enteredCpu(clock);
                gui.setCpuActive(process);
                // Update statistics
                statistics.nofProcessSwitches++;
            } else {
                // No active process, switch in a process if the queue is non-empty
                process = (Process)queue.removeNext();
                process.enteredCpu(clock);
                gui.setCpuActive(process);
            }
        }

        return process != null ? process.getNextEvent(clock, maxTime) : null;
    }


    /**
     * Called when the active process left the CPU (for example to perform I/O),
     * and a new process needs to be switched in.
     * @return  The event generated by the process switch, or null if no new
     *          process was switched in.
     */
    public Event activeProcessLeft(long clock) {

        process = null;

        gui.setCpuActive(null);

        return switchProcess(clock);
    }


}
